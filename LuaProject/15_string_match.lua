-- 下面的表列出了Lua支持的所有字符类：
-- 单个字符(除 ^$()%.[]*+-? 外): 与该字符自身配对
-- .(点): 与任何字符配对
-- %a: 与任何字母配对
-- %c: 与任何控制符配对(例如\n)
-- %d: 与任何数字配对
-- %l: 与任何小写字母配对
-- %p: 与任何标点(punctuation)配对
-- %s: 与空白字符配对
-- %u: 与任何大写字母配对
-- %w: 与任何字母/数字配对
-- %x: 与任何十六进制数配对
-- %z: 与任何代表0的字符配对
-- %x(此处x是非字母非数字字符): 与字符x配对. 主要用来处理表达式中有功能的字符(^$()%.[]*+-?)的配对问题, 例如%%与%配对
-- [数个字符类]: 与任何[]中包含的字符类配对. 例如[%w_]与任何字母/数字, 或下划线符号(_)配对
-- [^数个字符类]: 与任何不包含在[]中的字符类配对. 例如[^%s]与任何非空白字符配对
-- 当上述的字符类用大写书写时, 表示与非此字符类的任何字符配对. 例如, %S表示与任何非空白字符配对.例如，'%A'非字母的字符
print(string.gsub("hello, up-down!", "%A", "."))

-- string.gmatch(str, pattern)
-- 回一个迭代器函数，每一次调用这个函数，返回一个在字符串 str 找到的下一个符合 pattern 描述的子串。如果参数 pattern 描述的字符串没有找到，迭代函数返回nil。
for word in string.gmatch("hello lua user", "%a+") do
    print("gmatch:", word)
end
-- 	string.match(str, pattern, init)
-- string.match()只寻找源字串str中的(第一个配对!). 参数init可选, 指定搜寻过程的起点, 默认为1。 
-- 在成功配对时, 函数将返回配对表达式中的所有捕获结果; 如果没有设置捕获标记, 则返回整个配对字符串. 当没有成功的配对时, 返回nil。
print(string.match("I have 2 questions for you.", "%d %a"))                                 -->2 q
print(string.match("I have 2 questions for you.", "%d %a+"))                                -->2 questions
print(string.format("%d, %q", string.match("I have 2 questions for you.", "(%d+) (%a+)")))  -->2, "questions"

-- 在模式匹配中有一些特殊字符，他们有特殊的意义，Lua中的特殊字符如下：
-- ( ) . % + - * ? [ ^ $
-- '%' 用作特殊字符的转义字符，因此 '%.' 匹配点；'%%' 匹配字符 '%'。转义字符 '%'不仅可以用来转义特殊字符，还可以用于所有的非字母的字符。
-- 模式条目可以是：
-- 单个字符类匹配该类别中任意单个字符；
-- 单个字符类跟一个 '*'， 将匹配零或多个该类的字符。 这个条目总是匹配尽可能长的串；
-- 单个字符类跟一个 '+'， 将匹配一或更多个该类的字符。 这个条目总是匹配尽可能长的串；
-- 单个字符类跟一个 '-'， 将匹配零或更多个该类的字符。 和 '*' 不同， 这个条目总是匹配尽可能短的串；
-- 单个字符类跟一个 '?'， 将匹配零或一个该类的字符。 只要有可能，它会匹配一个；
-- %n， 这里的 n 可以从 1 到 9； 这个条目匹配一个等于 n 号捕获物（后面有描述）的子串。
-- %bxy， 这里的 x 和 y 是两个明确的字符； 这个条目匹配以 x 开始 y 结束， 且其中 x 和 y 保持 平衡 的字符串。 意思是，如果从左到右读这个字符串，对每次读到一个 x 就 +1 ，读到一个 y 就 -1， 最终结束处的那个 y 是第一个记数到 0 的 y。 举个例子，条目 %b() 可以匹配到括号平衡的表达式。
-- %f[set]， 指 边境模式； 这个条目会匹配到一个位于 set 内某个字符之前的一个空串， 且这个位置的前一个字符不属于 set 。 集合 set 的含义如前面所述。 匹配出的那个空串之开始和结束点的计算就看成该处有个字符 '\0' 一样。
-- 模式：
-- 模式 指一个模式条目的序列。 在模式最前面加上符号 '^' 将锚定从字符串的开始处做匹配。 在模式最后面加上符号 '$' 将使匹配过程锚定到字符串的结尾。 如果 '^' 和 '$' 出现在其它位置，它们均没有特殊含义，只表示自身。
-- 捕获：
-- 模式可以在内部用小括号括起一个子模式； 这些子模式被称为 捕获物。 当匹配成功时，由 捕获物 匹配到的字符串中的子串被保存起来用于未来的用途。 捕获物以它们左括号的次序来编号。 例如，对于模式 "(a*(.)%w(%s*))" ， 字符串中匹配到 "a*(.)%w(%s*)" 的部分保存在第一个捕获物中 （因此是编号 1 ）； 由 "." 匹配到的字符是 2 号捕获物， 匹配到 "%s*" 的那部分是 3 号。
-- 作为一个特例，空的捕获 () 将捕获到当前字符串的位置（它是一个数字）。 例如，如果将模式 "()aa()" 作用到字符串 "flaaap" 上，将产生两个捕获物： 3 和 5 。


-- 将阿拉伯数字转换为语文汉字数字：
local function NumToCN(num)
    local size = #tostring(num)
    local CN = ""
    local StrCN = {"One","Two","Three","Four","Five","Six","Seven","Eight","Nine"}
    for i = 1 , size do
        CN = CN .. StrCN[tonumber(string.sub(tostring(num), i , i))]
    end
    return CN
end
print(NumToCN(56665))

-- 移除中文部分：
function StrSplit(inputstr, sep)
    if sep == nil then
      sep = "%s"
    end
    local t={}
    local i=1
    for str in string.gmatch(inputstr, "([^"..sep.."]+)") do
       t[i] = str
       i = i + 1
    end
    return t
end
local a = "23245023496830,汉字。。。。"
local b = ":"
b = StrSplit(a,",")
print(b[1])
